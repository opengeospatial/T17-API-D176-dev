/**
 * Environmental Data Retrieval API\'s
 * Example of Candidate Environmental Data Retrieval API OpenAPI docs
 *
 * The version of the OpenAPI document: 0.0.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { CoverageJSON } from '../model/models';
import { Exception } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class CollectionDataQueriesService {

    protected basePath = 'http://www.example.org/edr';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Query end point for queries of collection {collectionId} defined by a location id
     * Return data the for the location defined by locid
     * @param collectionId Identifier (id) of a specific collection
     * @param locId Retreive data for the location defined by locId (i.e. London_Heathrow, EGLL, 03772 etc)
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCollectionDataForLocation(collectionId: string, locId: string, datetime?: string, crs?: string, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getCollectionDataForLocation(collectionId: string, locId: string, datetime?: string, crs?: string, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getCollectionDataForLocation(collectionId: string, locId: string, datetime?: string, crs?: string, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getCollectionDataForLocation(collectionId: string, locId: string, datetime?: string, crs?: string, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getCollectionDataForLocation.');
        }
        if (locId === null || locId === undefined) {
            throw new Error('Required parameter locId was null or undefined when calling getCollectionDataForLocation.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/locations/${encodeURIComponent(String(locId))}`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Query end point for area queries  of collection {collectionId} defined by a polygon
     * Return the data values for the data area defined by the query parameters
     * @param collectionId Identifier (id) of a specific collection
     * @param coords Only data that has a geometry that intersects the area defined by the polygon are selected.   The polygon is defined using a Well Known Text string following   coords&#x3D;POLYGON((x y,x1 y1,x2 y2,...,xn yn x y))  which are values in the coordinate system defined by the crs query parameter  (if crs is not defined the values will be assumed to be WGS84 longitude/latitude coordinates).    For instance a polygon that roughly describes an area that contains  South West England in WGS84 would look like:   coords&#x3D;POLYGON((-6.1 50.3,-4.35 51.4,-2.6 51.6,-2.8 50.6,-5.3 49.9,-6.1,50.3))  see http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 and  https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry  The coords parameter will only support 2D POLYGON definitions
     * @param z Define the vertical level to return data from  i.e. z&#x3D;level  for instance if the 850hPa pressure level is being queried  z&#x3D;850  or a range to return data for all levels between and including 2 defined levels i.e. z&#x3D;minimum value/maximum value  for instance if all values between and including 10m and 100m  z&#x3D;10/100  finally a list of height values can be specified i.e. z&#x3D;value1,value2,value3  for instance if values at 2m, 10m and 80m are required  z&#x3D;2,10,80  An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start  and the amount to increment the height by is defined at the end  i.e. z&#x3D;Rn/min height/height interval  so if the request was for 20 height levels 50m apart starting at 100m:  z&#x3D;R20/100/50  When not specified data from all available heights SHOULD be returned 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param parameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param resolutionX Defined it the user requires data at a different resolution from the native resolution of the data along the x-axis  If this is a single value it denotes the number of intervals to retrieve data for along the x-axis      i.e. resolution-x&#x3D;10     would retrieve 10 values along the x-axis from the minimum x coordinate to maximum x coordinate (i.e. a value at both the minimum x and maximum x coordinates and 8 values between). 
     * @param resolutionY Defined it the user requires data at a different resolution from the native resolution of the data along the y-axis  If this is a single value it denotes the number of intervals to retrieve data for along the y-axis      i.e. resolution-y&#x3D;10     would retrieve 10 values along the y-axis from the minimum y coordinate to maximum y coordinate (i.e. a value at both the minimum y and maximum y coordinates and 8 values between). 
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForArea(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, resolutionX?: object, resolutionY?: object, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getDataForArea(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, resolutionX?: object, resolutionY?: object, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getDataForArea(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, resolutionX?: object, resolutionY?: object, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getDataForArea(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, resolutionX?: object, resolutionY?: object, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForArea.');
        }
        if (coords === null || coords === undefined) {
            throw new Error('Required parameter coords was null or undefined when calling getDataForArea.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (coords !== undefined && coords !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>coords, 'coords');
        }
        if (z !== undefined && z !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>z, 'z');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (parameterName !== undefined && parameterName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parameterName, 'parameter-name');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (resolutionX !== undefined && resolutionX !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>resolutionX, 'resolution-x');
        }
        if (resolutionY !== undefined && resolutionY !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>resolutionY, 'resolution-y');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/area`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Query end point for Corridor queries  of collection {collectionId} defined by a polygon
     * Return the data values for the Corridor defined by the query parameters
     * @param collectionId Identifier (id) of a specific collection
     * @param coords Only data that has a geometry that intersects the area defined by the linestring are selected.   The trajectory is defined using a Well Known Text string following   A 2D trajectory, on the surface of earth with no time or height dimensions:      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )  A 2D trajectory, on the surface of earth with all for the same time and no height dimension, time value defined in ISO8601 format by the &#x60;datetime&#x60; query parameter :      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36 ,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )&amp;time&#x3D;2018-02-12T23:00:00Z       A 2D trajectory, on the surface of earth with no time value but at a fixed height level, height defined in the collection height units by the &#x60;z&#x60; query parameter :      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36 ,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )&amp;z&#x3D;850   A 2D trajectory, on the surface of earth with all for the same time and at a fixed height level, time value defined in ISO8601 format by the &#x60;datetime&#x60; query parameter and height defined in the collection height units by the &#x60;z&#x60; query parameter :      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36 ,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )&amp;time&#x3D;2018-02-12T23:00:00Z&amp;z&#x3D;850   A 3D trajectory, on the surface of the earth but over a time range with no height values: coords&#x3D;LINESTRINGM(-2.87 51.14  1560507000,-2.98 51.36  1560507600,-3.15 51.03  1560508200,-3.48 50.74  1560508500,-3.36 50.9  1560510240)  A 3D trajectory, on the surface of the earth but over a time range with a fixed height value, height defined in the collection height units by the &#x60;z&#x60; query parameter :  coords&#x3D;LINESTRINGM(-2.87 51.14  1560507000,-2.98 51.36  1560507600,-3.15 51.03  1560508200,-3.48 50.74  1560508500,-3.36 50.9  1560510240)&amp;z&#x3D;200   A 3D trajectory, through a 3D volume with height or depth, but no defined time: coords&#x3D;LINESTRINGZ(-2.87 51.14  0.1,-2.98 51.36  0.2,-3.15 51.03  0.3,-3.48 50.74  0.4,-3.36 50.9  0.5)  A 3D trajectory, through a 3D volume with height or depth, but a fixed time time value defined in ISO8601 format by the &#x60;datetime&#x60; query parameter: coords&#x3D;LINESTRINGZ(-2.87 51.14  0.1,-2.98 51.36  0.2,-3.15 51.03  0.3,-3.48 50.74  0.4,-3.36 50.9  0.5)&amp;time&#x3D;2018-02-12T23:00:00Z  A 4D trajectory, through a 3D volume but over a time range: coords&#x3D;LINESTRINGZM(-2.87 51.14 0.1 1560507000,-2.98 51.36 0.2 1560507600,-3.15 51.03 0.3 1560508200, -3.48 50.74 0.4 1560508500, -3.36 50.9 0.5 1560510240) (using either the &#x60;time&#x60; or &#x60;z&#x60; parameters with a 4D trajectory wil generate an error response)  where Z in &#x60;LINESTRINGZ&#x60; and &#x60;LINESTRINGZM&#x60; refers to the height value.   &#x60;If the specified CRS does not define the height units, the heights units will default to metres above mean sea level&#x60;  and the M in &#x60;LINESTRINGM&#x60; and &#x60;LINESTRINGZM&#x60; refers to the number of seconds that have elapsed since the Unix epoch, that is the time 00:00:00 UTC on 1 January 1970. See https://en.wikipedia.org/wiki/Unix_time
     * @param corridorWidth width of the corridor  The width value represents the whole width of the corridor where the trajectory supplied in the &#x60;coords&#x60; query parameter is the centre point of the corridor  &#x60;corridor-width&#x3D;{width}&#x60;  e.g.  corridor-width&#x3D;100  Would be a request for a corridor 100 units wide with the coords parameter values being the centre point of the requested corridor,  the request would be for data values 50 units either side of the trajectory coordinates defined in the coords parameter.   The width units supported by the collection will be provided in the API metadata responses 
     * @param widthUnits Distance units for the corridor-width parameter
     * @param corridorHeight height of the corridor  The height value represents the whole height of the corridor where the trajectory supplied in the &#x60;coords&#x60; query parameter is the centre point of the corridor  &#x60;corridor-height&#x3D;{height}&#x60;  e.g.  corridor-height&#x3D;100  Would be a request for a corridor 100 units high with the coords parameter values being the centre point of the requested corridor,  the request would be for data values 50 units either side of the trajectory coordinates defined in the coords parameter.   The height units supported by the collection will be provided in the API metadata responses 
     * @param heightUnits Distance units for the corridor-height parameter
     * @param z Define the vertical level to return data from  i.e. z&#x3D;level  for instance if the 850hPa pressure level is being queried  z&#x3D;850  or a range to return data for all levels between and including 2 defined levels i.e. z&#x3D;minimum value/maximum value  for instance if all values between and including 10m and 100m  z&#x3D;10/100  finally a list of height values can be specified i.e. z&#x3D;value1,value2,value3  for instance if values at 2m, 10m and 80m are required  z&#x3D;2,10,80  An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start  and the amount to increment the height by is defined at the end  i.e. z&#x3D;Rn/min height/height interval  so if the request was for 20 height levels 50m apart starting at 100m:  z&#x3D;R20/100/50  When not specified data from all available heights SHOULD be returned 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param parameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
     * @param resolutionX Defined it the user requires data at a different resolution from the native resolution of the data along the x-axis  If this is a single value it denotes the number of intervals to retrieve data for along the x-axis      i.e. resolution-x&#x3D;10     would retrieve 10 values along the x-axis from the minimum x coordinate to maximum x coordinate (i.e. a value at both the minimum x and maximum x coordinates and 8 values between). 
     * @param resolutionZ Defined it the user requires data at a different resolution from the native resolution of the data along the z-axis  If this is a single value it denotes the number of intervals to retrieve data for along the z-axis      i.e. resolution-z&#x3D;10     would retrieve 10 values along the z-axis from the minimum z coordinate to maximum z  coordinate (i.e. a value at both the minimum z and maximum z coordinates and 8 values between). 
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForCorridor(collectionId: string, coords: string, corridorWidth: string, widthUnits: string, corridorHeight: string, heightUnits: string, z?: string, datetime?: string, parameterName?: string, resolutionX?: object, resolutionZ?: object, crs?: string, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getDataForCorridor(collectionId: string, coords: string, corridorWidth: string, widthUnits: string, corridorHeight: string, heightUnits: string, z?: string, datetime?: string, parameterName?: string, resolutionX?: object, resolutionZ?: object, crs?: string, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getDataForCorridor(collectionId: string, coords: string, corridorWidth: string, widthUnits: string, corridorHeight: string, heightUnits: string, z?: string, datetime?: string, parameterName?: string, resolutionX?: object, resolutionZ?: object, crs?: string, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getDataForCorridor(collectionId: string, coords: string, corridorWidth: string, widthUnits: string, corridorHeight: string, heightUnits: string, z?: string, datetime?: string, parameterName?: string, resolutionX?: object, resolutionZ?: object, crs?: string, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForCorridor.');
        }
        if (coords === null || coords === undefined) {
            throw new Error('Required parameter coords was null or undefined when calling getDataForCorridor.');
        }
        if (corridorWidth === null || corridorWidth === undefined) {
            throw new Error('Required parameter corridorWidth was null or undefined when calling getDataForCorridor.');
        }
        if (widthUnits === null || widthUnits === undefined) {
            throw new Error('Required parameter widthUnits was null or undefined when calling getDataForCorridor.');
        }
        if (corridorHeight === null || corridorHeight === undefined) {
            throw new Error('Required parameter corridorHeight was null or undefined when calling getDataForCorridor.');
        }
        if (heightUnits === null || heightUnits === undefined) {
            throw new Error('Required parameter heightUnits was null or undefined when calling getDataForCorridor.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (coords !== undefined && coords !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>coords, 'coords');
        }
        if (z !== undefined && z !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>z, 'z');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (parameterName !== undefined && parameterName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parameterName, 'parameter-name');
        }
        if (corridorWidth !== undefined && corridorWidth !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>corridorWidth, 'corridor-width');
        }
        if (widthUnits !== undefined && widthUnits !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>widthUnits, 'width-units');
        }
        if (corridorHeight !== undefined && corridorHeight !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>corridorHeight, 'corridor-height');
        }
        if (heightUnits !== undefined && heightUnits !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>heightUnits, 'height-units');
        }
        if (resolutionX !== undefined && resolutionX !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>resolutionX, 'resolution-x');
        }
        if (resolutionZ !== undefined && resolutionZ !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>resolutionZ, 'resolution-z');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/corridor`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Query end point for Cube queries  of collection {collectionId} defined by a cube
     * Return the data values for the data Cube defined by the query parameters
     * @param collectionId Identifier (id) of a specific collection
     * @param bbox Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth): * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional) The coordinate reference system of the values is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter &#x60;bbox-crs&#x60;. For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge). If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box. If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
     * @param z Define the vertical levels to return data from   A range to return data for all levels between and including 2 defined levels  i.e. z&#x3D;minimum value/maximum value  for instance if all values between and including 10m and 100m  z&#x3D;10/100  A list of height values can be specified i.e. z&#x3D;value1,value2,value3  for instance if values at 2m, 10m and 80m are required  z&#x3D;2,10,80  An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start  and the amount to increment the height by is defined at the end  i.e. z&#x3D;Rn/min height/height interval  so if the request was for 20 height levels 50m apart starting at 100m:  z&#x3D;R20/100/50  When not specified data from all available heights SHOULD be returned 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param parameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForCube(collectionId: string, bbox?: object, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getDataForCube(collectionId: string, bbox?: object, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getDataForCube(collectionId: string, bbox?: object, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getDataForCube(collectionId: string, bbox?: object, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForCube.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (bbox !== undefined && bbox !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bbox, 'bbox');
        }
        if (z !== undefined && z !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>z, 'z');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (parameterName !== undefined && parameterName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parameterName, 'parameter-name');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/cube`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return item {itemId} from collection {collectionId}
     * Query end point to retrieve data from collection {collectionId} using a unique identifier
     * @param collectionId Identifier (id) of a specific collection
     * @param itemId Retrieve data from the collection using a unique identifier.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForItem(collectionId: string, itemId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'text/xml' | 'application/x-netcdf' | 'text/html'}): Observable<any>;
    public getDataForItem(collectionId: string, itemId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'text/xml' | 'application/x-netcdf' | 'text/html'}): Observable<HttpResponse<any>>;
    public getDataForItem(collectionId: string, itemId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'text/xml' | 'application/x-netcdf' | 'text/html'}): Observable<HttpEvent<any>>;
    public getDataForItem(collectionId: string, itemId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'text/xml' | 'application/x-netcdf' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForItem.');
        }
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling getDataForItem.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'text/xml',
                'application/x-netcdf',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/items/${encodeURIComponent(String(itemId))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Query end point for position queries  of collection {collectionId}
     * Query end point for position queries
     * @param collectionId Identifier (id) of a specific collection
     * @param coords location(s) to return data for, the coordinates are defined by a Well Known Text (wkt) string. to retrieve a single location :  POINT(x y) i.e. POINT(0 51.48) for Greenwich, London  And for a list of locations  MULTIPOINT((x y),(x1 y1),(x2 y2),(x3 y3))  i.e. MULTIPOINT((38.9 -77),(48.85 2.35),(39.92 116.38),(-35.29 149.1),(51.5 -0.1))  see http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 and  https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry  the coordinate values will depend on the CRS parameter, if this is not defined the values will be assumed to WGS84 values (i.e x&#x3D;longitude and y&#x3D;latitude) 
     * @param z Define the vertical level to return data from  i.e. z&#x3D;level  for instance if the 850hPa pressure level is being queried  z&#x3D;850  or a range to return data for all levels between and including 2 defined levels i.e. z&#x3D;minimum value/maximum value  for instance if all values between and including 10m and 100m  z&#x3D;10/100  finally a list of height values can be specified i.e. z&#x3D;value1,value2,value3  for instance if values at 2m, 10m and 80m are required  z&#x3D;2,10,80  An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start  and the amount to increment the height by is defined at the end  i.e. z&#x3D;Rn/min height/height interval  so if the request was for 20 height levels 50m apart starting at 100m:  z&#x3D;R20/100/50  When not specified data from all available heights SHOULD be returned 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param parameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForPoint(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getDataForPoint(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getDataForPoint(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getDataForPoint(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForPoint.');
        }
        if (coords === null || coords === undefined) {
            throw new Error('Required parameter coords was null or undefined when calling getDataForPoint.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (coords !== undefined && coords !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>coords, 'coords');
        }
        if (z !== undefined && z !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>z, 'z');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (parameterName !== undefined && parameterName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parameterName, 'parameter-name');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/position`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Query end point for radius queries  of collection {collectionId}
     * Query end point for to return values within a defined radius of a point queries
     * @param collectionId Identifier (id) of a specific collection
     * @param coords location(s) to return data for, the coordinates are defined by a Well Known Text (wkt) string. to retrieve a single location :  POINT(x y) i.e. POINT(0 51.48) for Greenwich, London  see http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 and  https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry  the coordinate values will depend on the CRS parameter, if this is not defined the values will be assumed to WGS84 values (i.e x&#x3D;longitude and y&#x3D;latitude) 
     * @param within Defines radius of area around defined coordinates to include in the data selection
     * @param withinUnits Distance units for the within parameter
     * @param z Define the vertical level to return data from  i.e. z&#x3D;level  for instance if the 850hPa pressure level is being queried  z&#x3D;850  or a range to return data for all levels between and including 2 defined levels i.e. z&#x3D;minimum value/maximum value  for instance if all values between and including 10m and 100m  z&#x3D;10/100  finally a list of height values can be specified i.e. z&#x3D;value1,value2,value3  for instance if values at 2m, 10m and 80m are required  z&#x3D;2,10,80  An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start  and the amount to increment the height by is defined at the end  i.e. z&#x3D;Rn/min height/height interval  so if the request was for 20 height levels 50m apart starting at 100m:  z&#x3D;R20/100/50  When not specified data from all available heights SHOULD be returned 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param parameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForRadius(collectionId: string, coords: string, within: number, withinUnits: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getDataForRadius(collectionId: string, coords: string, within: number, withinUnits: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getDataForRadius(collectionId: string, coords: string, within: number, withinUnits: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getDataForRadius(collectionId: string, coords: string, within: number, withinUnits: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForRadius.');
        }
        if (coords === null || coords === undefined) {
            throw new Error('Required parameter coords was null or undefined when calling getDataForRadius.');
        }
        if (within === null || within === undefined) {
            throw new Error('Required parameter within was null or undefined when calling getDataForRadius.');
        }
        if (withinUnits === null || withinUnits === undefined) {
            throw new Error('Required parameter withinUnits was null or undefined when calling getDataForRadius.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (coords !== undefined && coords !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>coords, 'coords');
        }
        if (within !== undefined && within !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>within, 'within');
        }
        if (withinUnits !== undefined && withinUnits !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>withinUnits, 'within-units');
        }
        if (z !== undefined && z !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>z, 'z');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (parameterName !== undefined && parameterName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parameterName, 'parameter-name');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/radius`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Query end point for trajectory queries  of collection {collectionId} defined by a wkt linestring and a iso8601 time period
     * Return the data values for the data Polygon defined by the query parameters
     * @param collectionId Identifier (id) of a specific collection
     * @param coords Only data that has a geometry that intersects the area defined by the linestring are selected.   The trajectory is defined using a Well Known Text string following   A 2D trajectory, on the surface of earth with no time or height dimensions:      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )  A 2D trajectory, on the surface of earth with all for the same time and no height dimension, time value defined in ISO8601 format by the &#x60;datetime&#x60; query parameter :      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36 ,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )&amp;time&#x3D;2018-02-12T23:00:00Z       A 2D trajectory, on the surface of earth with no time value but at a fixed height level, height defined in the collection height units by the &#x60;z&#x60; query parameter :      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36 ,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )&amp;z&#x3D;850   A 2D trajectory, on the surface of earth with all for the same time and at a fixed height level, time value defined in ISO8601 format by the &#x60;datetime&#x60; query parameter and height defined in the collection height units by the &#x60;z&#x60; query parameter :      coords&#x3D;LINESTRING(-2.87 51.14 , -2.98 51.36 ,-3.15 51.03 ,-3.48 50.74 ,-3.36 50.9 )&amp;time&#x3D;2018-02-12T23:00:00Z&amp;z&#x3D;850   A 3D trajectory, on the surface of the earth but over a time range with no height values: coords&#x3D;LINESTRINGM(-2.87 51.14  1560507000,-2.98 51.36  1560507600,-3.15 51.03  1560508200,-3.48 50.74  1560508500,-3.36 50.9  1560510240)  A 3D trajectory, on the surface of the earth but over a time range with a fixed height value, height defined in the collection height units by the &#x60;z&#x60; query parameter :  coords&#x3D;LINESTRINGM(-2.87 51.14  1560507000,-2.98 51.36  1560507600,-3.15 51.03  1560508200,-3.48 50.74  1560508500,-3.36 50.9  1560510240)&amp;z&#x3D;200   A 3D trajectory, through a 3D volume with height or depth, but no defined time: coords&#x3D;LINESTRINGZ(-2.87 51.14  0.1,-2.98 51.36  0.2,-3.15 51.03  0.3,-3.48 50.74  0.4,-3.36 50.9  0.5)  A 3D trajectory, through a 3D volume with height or depth, but a fixed time time value defined in ISO8601 format by the &#x60;datetime&#x60; query parameter: coords&#x3D;LINESTRINGZ(-2.87 51.14  0.1,-2.98 51.36  0.2,-3.15 51.03  0.3,-3.48 50.74  0.4,-3.36 50.9  0.5)&amp;time&#x3D;2018-02-12T23:00:00Z  A 4D trajectory, through a 3D volume but over a time range: coords&#x3D;LINESTRINGZM(-2.87 51.14 0.1 1560507000,-2.98 51.36 0.2 1560507600,-3.15 51.03 0.3 1560508200, -3.48 50.74 0.4 1560508500, -3.36 50.9 0.5 1560510240) (using either the &#x60;time&#x60; or &#x60;z&#x60; parameters with a 4D trajectory wil generate an error response)  where Z in &#x60;LINESTRINGZ&#x60; and &#x60;LINESTRINGZM&#x60; refers to the height value.   &#x60;If the specified CRS does not define the height units, the heights units will default to metres above mean sea level&#x60;  and the M in &#x60;LINESTRINGM&#x60; and &#x60;LINESTRINGZM&#x60; refers to the number of seconds that have elapsed since the Unix epoch, that is the time 00:00:00 UTC on 1 January 1970. See https://en.wikipedia.org/wiki/Unix_time
     * @param z Define the vertical level to return data from  i.e. z&#x3D;level  for instance if the 850hPa pressure level is being queried  z&#x3D;850  or a range to return data for all levels between and including 2 defined levels i.e. z&#x3D;minimum value/maximum value  for instance if all values between and including 10m and 100m  z&#x3D;10/100  finally a list of height values can be specified i.e. z&#x3D;value1,value2,value3  for instance if values at 2m, 10m and 80m are required  z&#x3D;2,10,80  An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start  and the amount to increment the height by is defined at the end  i.e. z&#x3D;Rn/min height/height interval  so if the request was for 20 height levels 50m apart starting at 100m:  z&#x3D;R20/100/50  When not specified data from all available heights SHOULD be returned 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots. Examples: * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot; Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param parameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
     * @param crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
     * @param f format to return the data response in
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataForTrajectory(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<CoverageJSON>;
    public getDataForTrajectory(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpResponse<CoverageJSON>>;
    public getDataForTrajectory(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<HttpEvent<CoverageJSON>>;
    public getDataForTrajectory(collectionId: string, coords: string, z?: string, datetime?: string, parameterName?: string, crs?: string, f?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/prs.coverage+json' | 'application/geo+json' | 'application/x-netcdf' | 'text/xml' | 'application/json' | 'text/html'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling getDataForTrajectory.');
        }
        if (coords === null || coords === undefined) {
            throw new Error('Required parameter coords was null or undefined when calling getDataForTrajectory.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (coords !== undefined && coords !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>coords, 'coords');
        }
        if (z !== undefined && z !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>z, 'z');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (parameterName !== undefined && parameterName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parameterName, 'parameter-name');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/prs.coverage+json',
                'application/geo+json',
                'application/x-netcdf',
                'text/xml',
                'application/json',
                'text/html'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<CoverageJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/trajectory`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
