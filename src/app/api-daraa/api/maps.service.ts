/**
 * Daraa
 * This data store is offered by CubeWerx Inc. as a demonstration of its in-progress OGC API implementation.
 *
 * The version of the OpenAPI document: 9.3.52
 * Contact: mgalluch@cubewerx.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';


import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class MapsService {

    protected basePath = 'https://test.cubewerx.com/cubewerx/cubeserv/demo/ogcapi/Daraa';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * A map layer of the specified collection.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store that\&#39;s compatible with the specified collection.  If no styleId parameter is present, the default style of the collection will be rendered.
     * @param crs The coordinate reference system of the map.  If present, the bbox parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param bbox The spatial extent of the map in crs units.  Syntax: \&quot;minx,miny,maxx,maxy\&quot;.  If present, the crs parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param width The width (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param height The height (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339.  Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only elements that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public collectionsCollectionIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdMapGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (styleId !== undefined && styleId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>styleId, 'styleId');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (bbox) {
            queryParameters = this.addToHttpParams(queryParameters,
                bbox.join(COLLECTION_FORMATS['csv']), 'bbox');
        }
        if (width !== undefined && width !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>height, 'height');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/map`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A legend image showing a graphical representation of the specified collection as it would appear in the corresponding map.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store that\&#39;s compatible with the specified collection.  If no styleId parameter is present, the default style of the collection will be rendered.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param textcolor Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
     * @param scale If specified, a legend graphic specific to this scale (expressed as a scale denominator) will be returned.  Otherwise, a possibly-composite image providing a legend graphic for each of the scale ranges defined by the style will be returned.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public collectionsCollectionIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdMapLegendGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (styleId !== undefined && styleId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>styleId, 'styleId');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (textcolor !== undefined && textcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>textcolor, 'textcolor');
        }
        if (scale !== undefined && scale !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>scale, 'scale');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/map/legend`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A map layer of the specified collection in the specified style.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store.
     * @param crs The coordinate reference system of the map.  If present, the bbox parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param bbox The spatial extent of the map in crs units.  Syntax: \&quot;minx,miny,maxx,maxy\&quot;.  If present, the crs parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param width The width (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param height The height (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339.  Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only elements that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdStylesStyleIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public collectionsCollectionIdStylesStyleIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdStylesStyleIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdStylesStyleIdMapGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdStylesStyleIdMapGet.');
        }
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling collectionsCollectionIdStylesStyleIdMapGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (bbox) {
            queryParameters = this.addToHttpParams(queryParameters,
                bbox.join(COLLECTION_FORMATS['csv']), 'bbox');
        }
        if (width !== undefined && width !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>height, 'height');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/styles/${encodeURIComponent(String(styleId))}/map`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A legend image showing a graphical representation of the specified collection as it would appear in the corresponding map in the specified style.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param textcolor Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
     * @param scale If specified, a legend graphic specific to this scale (expressed as a scale denominator) will be returned.  Otherwise, a possibly-composite image providing a legend graphic for each of the scale ranges defined by the style will be returned.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdStylesStyleIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public collectionsCollectionIdStylesStyleIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdStylesStyleIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdStylesStyleIdMapLegendGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdStylesStyleIdMapLegendGet.');
        }
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling collectionsCollectionIdStylesStyleIdMapLegendGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (textcolor !== undefined && textcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>textcolor, 'textcolor');
        }
        if (scale !== undefined && scale !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>scale, 'scale');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/styles/${encodeURIComponent(String(styleId))}/map/legend`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A map layer consisting of one or more collections.
     * @param collections A comma-separated list of collection identifiers indicating the collections to be rendered.  Each of the specified collections must be renderable in the specified style.  The leftmost collection in the list will be rendered bottommost, the next one over that, and so on.  In the absence of a collections parameter, all of the collections that are renderable in specified style are rendered, in the order that the server deems most appropriate.
     * @param styleId The identifier of a style in this data store.  If no collections parameter is present, all of the collections that are renderable in this style are rendered in this style.  If a collections parameter is present, all of the specified collections must be renderable in the specified style.  If no styleId parameter is present, the default style of each of the specified collections (or of all mappable collections in the absence of a collections parameter) will be rendered.
     * @param crs The coordinate reference system of the map.  If present, the bbox parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param bbox The spatial extent of the map in crs units.  Syntax: \&quot;minx,miny,maxx,maxy\&quot;.  If present, the crs parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param width The width (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param height The height (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339.  Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only elements that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mapGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public mapGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public mapGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public mapGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (collections) {
            queryParameters = this.addToHttpParams(queryParameters,
                collections.join(COLLECTION_FORMATS['csv']), 'collections');
        }
        if (styleId !== undefined && styleId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>styleId, 'styleId');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (bbox) {
            queryParameters = this.addToHttpParams(queryParameters,
                bbox.join(COLLECTION_FORMATS['csv']), 'bbox');
        }
        if (width !== undefined && width !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>height, 'height');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        /**let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }**/
        let responseType = "arraybuffer";

        return this.httpClient.get<any>(`${this.configuration.basePath}/map`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A legend image showing a graphical representation of one or more collections as they would appear in the corresponding map.
     * @param collections A comma-separated list of collection identifiers indicating the collections to be rendered.  Each of the specified collections must be renderable in the specified style.  The leftmost collection in the list will be rendered bottommost, the next one over that, and so on.  In the absence of a collections parameter, all of the collections that are renderable in specified style are rendered, in the order that the server deems most appropriate.
     * @param styleId The identifier of a style in this data store.  If no collections parameter is present, all of the collections that are renderable in this style are rendered in this style.  If a collections parameter is present, all of the specified collections must be renderable in the specified style.  If no styleId parameter is present, the default style of each of the specified collections (or of all mappable collections in the absence of a collections parameter) will be rendered.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param textcolor Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
     * @param scale If specified, a legend graphic specific to this scale (expressed as a scale denominator) will be returned.  Otherwise, a possibly-composite image providing a legend graphic for each of the scale ranges defined by the style will be returned.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mapLegendGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public mapLegendGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public mapLegendGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public mapLegendGet(collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, styleId?: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (collections) {
            queryParameters = this.addToHttpParams(queryParameters,
                collections.join(COLLECTION_FORMATS['csv']), 'collections');
        }
        if (styleId !== undefined && styleId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>styleId, 'styleId');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (textcolor !== undefined && textcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>textcolor, 'textcolor');
        }
        if (scale !== undefined && scale !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>scale, 'scale');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/map/legend`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A map layer consisting of one or more collections in the specified style.
     * @param styleId The identifier of a style in this data store.  If no collections parameter is present, all of the collections that are renderable in this style are rendered in this style.  If a collections parameter is present, all of the specified collections must be renderable in the specified style.
     * @param collections A comma-separated list of collection identifiers indicating the collections to be rendered.  Each of the specified collections must be renderable in the specified style.  The leftmost collection in the list will be rendered bottommost, the next one over that, and so on.  In the absence of a collections parameter, all of the collections that are renderable in specified style are rendered, in the order that the server deems most appropriate.
     * @param crs The coordinate reference system of the map.  If present, the bbox parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param bbox The spatial extent of the map in crs units.  Syntax: \&quot;minx,miny,maxx,maxy\&quot;.  If present, the crs parameter must also be present.  If not present, the extent and native coordinate reference system of the thing being mapped will be used.
     * @param width The width (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param height The height (in pixels) of the map.  If unspecified, a reasonable default will be used.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339.  Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only elements that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesStyleIdMapGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public stylesStyleIdMapGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public stylesStyleIdMapGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public stylesStyleIdMapGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, crs?: string, bbox?: Array<number>, width?: number, height?: number, transparent?: boolean, bgcolor?: string, pixelSize?: number, datetime?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling stylesStyleIdMapGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (collections) {
            queryParameters = this.addToHttpParams(queryParameters,
                collections.join(COLLECTION_FORMATS['csv']), 'collections');
        }
        if (crs !== undefined && crs !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>crs, 'crs');
        }
        if (bbox) {
            queryParameters = this.addToHttpParams(queryParameters,
                bbox.join(COLLECTION_FORMATS['csv']), 'bbox');
        }
        if (width !== undefined && width !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>height, 'height');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (datetime !== undefined && datetime !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>datetime, 'datetime');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/styles/${encodeURIComponent(String(styleId))}/map`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A legend image showing a graphical representation of one or more collections as they would appear in the corresponding map in the specified style.
     * @param styleId The identifier of a style in this data store.  If no collections parameter is present, all of the collections that are renderable in this style are rendered in this style.  If a collections parameter is present, all of the specified collections must be renderable in the specified style.
     * @param collections A comma-separated list of collection identifiers indicating the collections to be rendered.  Each of the specified collections must be renderable in the specified style.  The leftmost collection in the list will be rendered bottommost, the next one over that, and so on.  In the absence of a collections parameter, all of the collections that are renderable in specified style are rendered, in the order that the server deems most appropriate.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param textcolor Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
     * @param scale If specified, a legend graphic specific to this scale (expressed as a scale denominator) will be returned.  Otherwise, a possibly-composite image providing a legend graphic for each of the scale ranges defined by the style will be returned.
     * @param pixelSize The physical linear size of a display pixel in millimetres.  If the display device has non-square pixels, then sqrt(width * height) should be provided.  The pixel units and scale rules in a style definition are with respect to a standardized rendering pixel size of 0.28mm.  Knowledge of the actual pixel size of the display device will allow the renderer to produce a map with the intended look even if the actual pixel size is significantly different from the standardized rendering pixel size.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesStyleIdMapLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any>;
    public stylesStyleIdMapLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpResponse<any>>;
    public stylesStyleIdMapLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<HttpEvent<any>>;
    public stylesStyleIdMapLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', collections?: Array<'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf'>, transparent?: boolean, bgcolor?: string, textcolor?: string, scale?: number, pixelSize?: number, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json'}): Observable<any> {
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling stylesStyleIdMapLegendGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (collections) {
            queryParameters = this.addToHttpParams(queryParameters,
                collections.join(COLLECTION_FORMATS['csv']), 'collections');
        }
        if (transparent !== undefined && transparent !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (textcolor !== undefined && textcolor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>textcolor, 'textcolor');
        }
        if (scale !== undefined && scale !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>scale, 'scale');
        }
        if (pixelSize !== undefined && pixelSize !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pixelSize, 'pixelSize');
        }
        if (f !== undefined && f !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>f, 'f');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (cwApiKeyHeader) required
        credential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (credential) {
            headers = headers.set('CubeWerx-API-Key', credential);
        }

        // authentication (cwApiKeyQuery) required
        credential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (credential) {
            queryParameters = queryParameters.set('apiKey', credential);
        }

        // authentication (cwAuth) required
        credential = this.configuration.lookupCredential('cwAuth');
        if (credential) {
        }

        // authentication (httpBearer) required
        credential = this.configuration.lookupCredential('httpBearer');
        if (credential) {
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        // authentication (oauth2) required
        credential = this.configuration.lookupCredential('oauth2');
        if (credential) {
            headers = headers.set('Authorization', 'Bearer ' + credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/styles/${encodeURIComponent(String(styleId))}/map/legend`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
